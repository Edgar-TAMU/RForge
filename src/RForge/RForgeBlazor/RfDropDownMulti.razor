@using RForge.Abstractions.DropDowns
@using RForgeBlazor.Services
@typeparam TItem

@inherits RfDropDownBase<TItem>

<div class="dropdown @DropdownCss">
    <div class="dropdown-trigger">
        <button class="button" type="button" aria-haspopup="true" aria-controls="dropdown-menu" @onclick="@OnDropDownClick">
            @if (SelectedItems == null || SelectedItems.Count == 0)
            {
                <span class="place-holder">@PlaceholderText</span>
            }
            else
            {
                <span class="field is-grouped is-grouped-multiline mb-0">

                    @foreach (var selectedItem in SelectedItems)
                    {
                        <span class="control">
                            <span class="tags has-addons">
                                <span class="tag @CssSelectedClass">

                                    @if (SelectedItemTemplate != null)
                                    {
                                        @SelectedItemTemplate(selectedItem)
                                    }
                                    else
                                    {
                                        @ChildContent(selectedItem)
                                    }
                                </span>
                                @if (IsReadonly == false)
                                {
                                    <a class="tag is-delete"
                                       tabindex="0"
                                       @onclick="@(async () => await OnDeselectClick(selectedItem))"
                                       @onclick:preventDefault="true"
                                       @onclick:stopPropagation="true"></a>
                                }
                            </span>
                        </span>
                    }
                </span>
            }
            <span class="rf-icon icon is-small @IsLoadingCss">
                <i class="fa-solid fa-angle-down" aria-hidden="true"></i>
                <span class="loader"></span>
            </span>
        </button>
    </div>
    <div class="dropdown-menu" id="dropdown-menu" role="menu">
        <div class="dropdown-content @CssHelper.AddIf(ShowFilter,"has-filter")">

            @if (ShowFilter == true)
            {
                bool hasFilterIcon = string.IsNullOrWhiteSpace(FilterIcon) == false && IsLoading == false;
                <div class="dropdown-item is-filter">
                    <div class="field">
                        <div class="control @CssHelper.AddIf(hasFilterIcon || IsLoading, "has-icons-right") @IsLoadingCss">
                            <input type="search" class="input" placeholder="@FilterPlaceholderText" @bind-value=Filter @oninput=@OnFilterChange />

                            @if (hasFilterIcon == true)
                            {
                                <span class="icon is-small is-right">
                                    <i class="@FilterIcon"></i>
                                </span>
                            }
                        </div>
                    </div>
                </div>
            }

            @if (Items == null || Items.Count == 0)
            {
                <a class="dropdown-item">
                    @EmptyContentText
                </a>
            }
            else
            {
                @foreach (var item in Items)
                {
                    string rowCss = null;
                    CssHelper.AddIfTrue(ref rowCss, IsSelected(item), "is-selected");

                    <a class="dropdown-item @CssRowItemClass @rowCss"
                       @onclick=@(async () => await OnItemClick(item))
                       @onkeydown=@(async (e) => await OnItemKeyDown(e, item))
                       tabindex="0">

                        @if (RowItemTemplate != null)
                        {
                            @RowItemTemplate(item)
                        }
                        else
                        {
                            @ChildContent(item)
                        }
                    </a>
                }
            }
        </div>
    </div>
</div>

@code {

    [Parameter]
    public List<TItem> SelectedItems { get; set; }
    [Parameter]
    public EventCallback<List<TItem>> SelectedItemsChanged { get; set; }

    [Parameter]
    public int? MaxSelectableItems { get; set; }

    [Parameter]
    public RfKeepRule MaxSelectionKeepRule { get; set; } = RfKeepRule.FirstInFirstOut;

    protected bool IsSelected(TItem item)
    {
        if (SelectedItems == null || SelectedItems.Count == 0) return false;

        return SelectedItems.Any(i => ItemComparer(i, item) == true);
    }

    private async Task OnItemClick(TItem item)
    {
        if (IsReadonly == true) return;

        bool isSelected = IsSelected(item);

        if (isSelected == true)
            SelectedItems.Remove(item);

        else if (MaxSelectableItems.HasValue == false
            || MaxSelectableItems <= 0
            || SelectedItems.Count < MaxSelectableItems)
        {
            SelectedItems.Add(item);
        }
        else
        {
            switch (MaxSelectionKeepRule)
            {
                case RfKeepRule.FirstInFirstOut:
                    SelectedItems.RemoveAt(0);
                    break;
                case RfKeepRule.FirstInLastOut:
                    SelectedItems.RemoveAt(SelectedItems.Count - 1);
                    break;
                case RfKeepRule.ForceDeselection:
                    return;
            }
        }

        await SelectedItemsChanged.InvokeAsync(SelectedItems);

        if (CloseOnSelect == true && IsOpen == true)
            await CloseDropDown();

        StateHasChanged();
    }

    private async Task OnItemKeyDown(KeyboardEventArgs e, TItem item)
    {
        if (e.Code == "Enter" || e.Code == "NumpadEnter")
        {
            await OnItemClick(item);
            return;
        }

        if (e.Code == "Escape")
        {
            await CloseDropDown();
        }

    }

    private async Task OnDeselectClick(TItem item)
    {
        if (IsReadonly == true) return;

        if (SelectedItems.Remove(item) == false) return;

        await SelectedItemsChanged.InvokeAsync(SelectedItems);
        StateHasChanged();
    }

}